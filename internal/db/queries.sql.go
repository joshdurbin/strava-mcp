// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const countActivities = `-- name: CountActivities :one
SELECT COUNT(*) FROM activities
`

func (q *Queries) CountActivities(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivities)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActivitiesByType = `-- name: CountActivitiesByType :one
SELECT COUNT(*) FROM activities WHERE type = ?
`

func (q *Queries) CountActivitiesByType(ctx context.Context, type_ sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivitiesByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActivitiesByTypeInRange = `-- name: CountActivitiesByTypeInRange :one
SELECT COUNT(*) FROM activities WHERE type = ? AND start_date >= ? AND start_date <= ?
`

type CountActivitiesByTypeInRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

func (q *Queries) CountActivitiesByTypeInRange(ctx context.Context, arg CountActivitiesByTypeInRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivitiesByTypeInRange, arg.Type, arg.StartDate, arg.StartDate_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActivitiesInRange = `-- name: CountActivitiesInRange :one

SELECT COUNT(*) FROM activities WHERE start_date >= ? AND start_date <= ?
`

type CountActivitiesInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

// Consolidated counting queries
func (q *Queries) CountActivitiesInRange(ctx context.Context, arg CountActivitiesInRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivitiesInRange, arg.StartDate, arg.StartDate_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActivitiesWithZones = `-- name: CountActivitiesWithZones :one
SELECT COUNT(DISTINCT activity_id) FROM activity_zones
`

func (q *Queries) CountActivitiesWithZones(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivitiesWithZones)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countActivitiesWithoutZones = `-- name: CountActivitiesWithoutZones :one
SELECT COUNT(*) FROM activities a
LEFT JOIN activity_zones az ON a.id = az.activity_id
WHERE az.id IS NULL
`

func (q *Queries) CountActivitiesWithoutZones(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivitiesWithoutZones)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createActivity = `-- name: CreateActivity :exec
INSERT INTO activities (
    id, name, distance, moving_time, elapsed_time, total_elevation_gain,
    type, sport_type, start_date, start_date_local, timezone,
    average_speed, max_speed, average_cadence, average_heartrate,
    max_heartrate, calories, created_at, updated_at
) VALUES (
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
ON CONFLICT(id) DO UPDATE SET
    name = excluded.name,
    distance = excluded.distance,
    moving_time = excluded.moving_time,
    elapsed_time = excluded.elapsed_time,
    total_elevation_gain = excluded.total_elevation_gain,
    type = excluded.type,
    sport_type = excluded.sport_type,
    start_date = excluded.start_date,
    start_date_local = excluded.start_date_local,
    timezone = excluded.timezone,
    average_speed = excluded.average_speed,
    max_speed = excluded.max_speed,
    average_cadence = excluded.average_cadence,
    average_heartrate = excluded.average_heartrate,
    max_heartrate = excluded.max_heartrate,
    calories = excluded.calories,
    updated_at = CURRENT_TIMESTAMP
`

type CreateActivityParams struct {
	ID                 int64           `json:"id"`
	Name               string          `json:"name"`
	Distance           sql.NullFloat64 `json:"distance"`
	MovingTime         sql.NullInt64   `json:"moving_time"`
	ElapsedTime        sql.NullInt64   `json:"elapsed_time"`
	TotalElevationGain sql.NullFloat64 `json:"total_elevation_gain"`
	Type               sql.NullString  `json:"type"`
	SportType          sql.NullString  `json:"sport_type"`
	StartDate          sql.NullTime    `json:"start_date"`
	StartDateLocal     sql.NullTime    `json:"start_date_local"`
	Timezone           sql.NullString  `json:"timezone"`
	AverageSpeed       sql.NullFloat64 `json:"average_speed"`
	MaxSpeed           sql.NullFloat64 `json:"max_speed"`
	AverageCadence     sql.NullFloat64 `json:"average_cadence"`
	AverageHeartrate   sql.NullFloat64 `json:"average_heartrate"`
	MaxHeartrate       sql.NullFloat64 `json:"max_heartrate"`
	Calories           sql.NullFloat64 `json:"calories"`
}

func (q *Queries) CreateActivity(ctx context.Context, arg CreateActivityParams) error {
	_, err := q.db.ExecContext(ctx, createActivity,
		arg.ID,
		arg.Name,
		arg.Distance,
		arg.MovingTime,
		arg.ElapsedTime,
		arg.TotalElevationGain,
		arg.Type,
		arg.SportType,
		arg.StartDate,
		arg.StartDateLocal,
		arg.Timezone,
		arg.AverageSpeed,
		arg.MaxSpeed,
		arg.AverageCadence,
		arg.AverageHeartrate,
		arg.MaxHeartrate,
		arg.Calories,
	)
	return err
}

const createActivityZone = `-- name: CreateActivityZone :one

INSERT INTO activity_zones (activity_id, zone_type, sensor_based)
VALUES (?, ?, ?)
ON CONFLICT(activity_id, zone_type) DO UPDATE SET
    sensor_based = excluded.sensor_based
RETURNING id
`

type CreateActivityZoneParams struct {
	ActivityID  int64  `json:"activity_id"`
	ZoneType    string `json:"zone_type"`
	SensorBased int64  `json:"sensor_based"`
}

// Activity zone queries
func (q *Queries) CreateActivityZone(ctx context.Context, arg CreateActivityZoneParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createActivityZone, arg.ActivityID, arg.ZoneType, arg.SensorBased)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createZoneBucket = `-- name: CreateZoneBucket :exec
INSERT INTO zone_buckets (activity_zone_id, zone_number, min_value, max_value, time_seconds)
VALUES (?, ?, ?, ?, ?)
`

type CreateZoneBucketParams struct {
	ActivityZoneID int64 `json:"activity_zone_id"`
	ZoneNumber     int64 `json:"zone_number"`
	MinValue       int64 `json:"min_value"`
	MaxValue       int64 `json:"max_value"`
	TimeSeconds    int64 `json:"time_seconds"`
}

func (q *Queries) CreateZoneBucket(ctx context.Context, arg CreateZoneBucketParams) error {
	_, err := q.db.ExecContext(ctx, createZoneBucket,
		arg.ActivityZoneID,
		arg.ZoneNumber,
		arg.MinValue,
		arg.MaxValue,
		arg.TimeSeconds,
	)
	return err
}

const deleteAuthConfig = `-- name: DeleteAuthConfig :exec
DELETE FROM auth_config WHERE id = 1
`

func (q *Queries) DeleteAuthConfig(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAuthConfig)
	return err
}

const deleteZoneBucketsForActivityZone = `-- name: DeleteZoneBucketsForActivityZone :exec
DELETE FROM zone_buckets WHERE activity_zone_id = ?
`

func (q *Queries) DeleteZoneBucketsForActivityZone(ctx context.Context, activityZoneID int64) error {
	_, err := q.db.ExecContext(ctx, deleteZoneBucketsForActivityZone, activityZoneID)
	return err
}

const getActivitiesByDateRange = `-- name: GetActivitiesByDateRange :many
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE start_date >= ? AND start_date <= ?
ORDER BY start_date DESC
`

type GetActivitiesByDateRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

func (q *Queries) GetActivitiesByDateRange(ctx context.Context, arg GetActivitiesByDateRangeParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, getActivitiesByDateRange, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.Type,
			&i.SportType,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageCadence,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.Calories,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivitiesByType = `-- name: GetActivitiesByType :many
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities WHERE type = ? ORDER BY start_date DESC
`

func (q *Queries) GetActivitiesByType(ctx context.Context, type_ sql.NullString) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, getActivitiesByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.Type,
			&i.SportType,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageCadence,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.Calories,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivitiesByTypeAndDateRange = `-- name: GetActivitiesByTypeAndDateRange :many
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities WHERE type = ? AND start_date >= ? AND start_date <= ? ORDER BY start_date DESC
`

type GetActivitiesByTypeAndDateRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

func (q *Queries) GetActivitiesByTypeAndDateRange(ctx context.Context, arg GetActivitiesByTypeAndDateRangeParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, getActivitiesByTypeAndDateRange, arg.Type, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.Type,
			&i.SportType,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageCadence,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.Calories,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivitiesWithZones = `-- name: GetActivitiesWithZones :many
SELECT DISTINCT a.id, a.name, a.type, a.sport_type, a.start_date
FROM activities a
JOIN activity_zones az ON a.id = az.activity_id
ORDER BY a.start_date DESC
LIMIT ?
`

type GetActivitiesWithZonesRow struct {
	ID        int64          `json:"id"`
	Name      string         `json:"name"`
	Type      sql.NullString `json:"type"`
	SportType sql.NullString `json:"sport_type"`
	StartDate sql.NullTime   `json:"start_date"`
}

func (q *Queries) GetActivitiesWithZones(ctx context.Context, limit int64) ([]GetActivitiesWithZonesRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivitiesWithZones, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivitiesWithZonesRow{}
	for rows.Next() {
		var i GetActivitiesWithZonesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.SportType,
			&i.StartDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivitiesWithoutZones = `-- name: GetActivitiesWithoutZones :many
SELECT a.id FROM activities a
LEFT JOIN activity_zones az ON a.id = az.activity_id
WHERE az.id IS NULL
ORDER BY a.start_date DESC
LIMIT ?
`

func (q *Queries) GetActivitiesWithoutZones(ctx context.Context, limit int64) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getActivitiesWithoutZones, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivity = `-- name: GetActivity :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities WHERE id = ?
`

func (q *Queries) GetActivity(ctx context.Context, id int64) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getActivity, id)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActivityCountsByMonth = `-- name: GetActivityCountsByMonth :many
SELECT 
    strftime('%Y-%m', start_date) as month,
    type,
    COUNT(*) as count
FROM activities 
WHERE start_date >= ? AND start_date <= ?
GROUP BY strftime('%Y-%m', start_date), type
ORDER BY month DESC, count DESC
`

type GetActivityCountsByMonthParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetActivityCountsByMonthRow struct {
	Month interface{}    `json:"month"`
	Type  sql.NullString `json:"type"`
	Count int64          `json:"count"`
}

func (q *Queries) GetActivityCountsByMonth(ctx context.Context, arg GetActivityCountsByMonthParams) ([]GetActivityCountsByMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivityCountsByMonth, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivityCountsByMonthRow{}
	for rows.Next() {
		var i GetActivityCountsByMonthRow
		if err := rows.Scan(&i.Month, &i.Type, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivityCountsByWeek = `-- name: GetActivityCountsByWeek :many
SELECT 
    strftime('%Y-W%W', start_date) as week,
    type,
    COUNT(*) as count
FROM activities 
WHERE start_date >= ? AND start_date <= ?
GROUP BY strftime('%Y-W%W', start_date), type
ORDER BY week DESC, count DESC
`

type GetActivityCountsByWeekParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetActivityCountsByWeekRow struct {
	Week  interface{}    `json:"week"`
	Type  sql.NullString `json:"type"`
	Count int64          `json:"count"`
}

func (q *Queries) GetActivityCountsByWeek(ctx context.Context, arg GetActivityCountsByWeekParams) ([]GetActivityCountsByWeekRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivityCountsByWeek, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivityCountsByWeekRow{}
	for rows.Next() {
		var i GetActivityCountsByWeekRow
		if err := rows.Scan(&i.Week, &i.Type, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivityTypeSummary = `-- name: GetActivityTypeSummary :many
SELECT type, COUNT(*) as count FROM activities WHERE type IS NOT NULL GROUP BY type ORDER BY count DESC
`

type GetActivityTypeSummaryRow struct {
	Type  sql.NullString `json:"type"`
	Count int64          `json:"count"`
}

func (q *Queries) GetActivityTypeSummary(ctx context.Context) ([]GetActivityTypeSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivityTypeSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivityTypeSummaryRow{}
	for rows.Next() {
		var i GetActivityTypeSummaryRow
		if err := rows.Scan(&i.Type, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivityTypeSummaryInRange = `-- name: GetActivityTypeSummaryInRange :many
SELECT type, COUNT(*) as count FROM activities
WHERE start_date >= ? AND start_date <= ? AND type IS NOT NULL
GROUP BY type ORDER BY count DESC
`

type GetActivityTypeSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetActivityTypeSummaryInRangeRow struct {
	Type  sql.NullString `json:"type"`
	Count int64          `json:"count"`
}

func (q *Queries) GetActivityTypeSummaryInRange(ctx context.Context, arg GetActivityTypeSummaryInRangeParams) ([]GetActivityTypeSummaryInRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getActivityTypeSummaryInRange, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActivityTypeSummaryInRangeRow{}
	for rows.Next() {
		var i GetActivityTypeSummaryInRangeRow
		if err := rows.Scan(&i.Type, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActivityZoneByActivityAndType = `-- name: GetActivityZoneByActivityAndType :one
SELECT id, activity_id, zone_type, sensor_based, created_at FROM activity_zones WHERE activity_id = ? AND zone_type = ?
`

type GetActivityZoneByActivityAndTypeParams struct {
	ActivityID int64  `json:"activity_id"`
	ZoneType   string `json:"zone_type"`
}

func (q *Queries) GetActivityZoneByActivityAndType(ctx context.Context, arg GetActivityZoneByActivityAndTypeParams) (ActivityZone, error) {
	row := q.db.QueryRowContext(ctx, getActivityZoneByActivityAndType, arg.ActivityID, arg.ZoneType)
	var i ActivityZone
	err := row.Scan(
		&i.ID,
		&i.ActivityID,
		&i.ZoneType,
		&i.SensorBased,
		&i.CreatedAt,
	)
	return i, err
}

const getActivityZones = `-- name: GetActivityZones :many
SELECT id, activity_id, zone_type, sensor_based, created_at FROM activity_zones WHERE activity_id = ?
`

func (q *Queries) GetActivityZones(ctx context.Context, activityID int64) ([]ActivityZone, error) {
	rows, err := q.db.QueryContext(ctx, getActivityZones, activityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActivityZone{}
	for rows.Next() {
		var i ActivityZone
		if err := rows.Scan(
			&i.ID,
			&i.ActivityID,
			&i.ZoneType,
			&i.SensorBased,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllActivities = `-- name: GetAllActivities :many
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities ORDER BY start_date DESC
`

func (q *Queries) GetAllActivities(ctx context.Context) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, getAllActivities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.Type,
			&i.SportType,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageCadence,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.Calories,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllActivityIDs = `-- name: GetAllActivityIDs :many
SELECT id FROM activities
`

func (q *Queries) GetAllActivityIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getAllActivityIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthConfig = `-- name: GetAuthConfig :one
SELECT id, client_id, client_secret, access_token, refresh_token, expires_at, created_at, updated_at FROM auth_config WHERE id = 1
`

func (q *Queries) GetAuthConfig(ctx context.Context) (AuthConfig, error) {
	row := q.db.QueryRowContext(ctx, getAuthConfig)
	var i AuthConfig
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.ClientSecret,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCadenceSummary = `-- name: GetCadenceSummary :one
SELECT 
    COALESCE(AVG(average_cadence), 0) as avg_cadence,
    COALESCE(MIN(average_cadence), 0) as min_cadence,
    COALESCE(MAX(average_cadence), 0) as max_cadence,
    COUNT(*) as activity_count
FROM activities 
WHERE average_cadence IS NOT NULL AND average_cadence > 0
`

type GetCadenceSummaryRow struct {
	AvgCadence    interface{} `json:"avg_cadence"`
	MinCadence    interface{} `json:"min_cadence"`
	MaxCadence    interface{} `json:"max_cadence"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetCadenceSummary(ctx context.Context) (GetCadenceSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getCadenceSummary)
	var i GetCadenceSummaryRow
	err := row.Scan(
		&i.AvgCadence,
		&i.MinCadence,
		&i.MaxCadence,
		&i.ActivityCount,
	)
	return i, err
}

const getCadenceSummaryByType = `-- name: GetCadenceSummaryByType :one
SELECT 
    COALESCE(AVG(average_cadence), 0) as avg_cadence,
    COALESCE(MIN(average_cadence), 0) as min_cadence,
    COALESCE(MAX(average_cadence), 0) as max_cadence,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND average_cadence IS NOT NULL AND average_cadence > 0
`

type GetCadenceSummaryByTypeRow struct {
	AvgCadence    interface{} `json:"avg_cadence"`
	MinCadence    interface{} `json:"min_cadence"`
	MaxCadence    interface{} `json:"max_cadence"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetCadenceSummaryByType(ctx context.Context, type_ sql.NullString) (GetCadenceSummaryByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, getCadenceSummaryByType, type_)
	var i GetCadenceSummaryByTypeRow
	err := row.Scan(
		&i.AvgCadence,
		&i.MinCadence,
		&i.MaxCadence,
		&i.ActivityCount,
	)
	return i, err
}

const getCadenceSummaryByTypeInRange = `-- name: GetCadenceSummaryByTypeInRange :one
SELECT 
    COALESCE(AVG(average_cadence), 0) as avg_cadence,
    COALESCE(MIN(average_cadence), 0) as min_cadence,
    COALESCE(MAX(average_cadence), 0) as max_cadence,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND start_date >= ? AND start_date <= ? AND average_cadence IS NOT NULL AND average_cadence > 0
`

type GetCadenceSummaryByTypeInRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetCadenceSummaryByTypeInRangeRow struct {
	AvgCadence    interface{} `json:"avg_cadence"`
	MinCadence    interface{} `json:"min_cadence"`
	MaxCadence    interface{} `json:"max_cadence"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetCadenceSummaryByTypeInRange(ctx context.Context, arg GetCadenceSummaryByTypeInRangeParams) (GetCadenceSummaryByTypeInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getCadenceSummaryByTypeInRange, arg.Type, arg.StartDate, arg.StartDate_2)
	var i GetCadenceSummaryByTypeInRangeRow
	err := row.Scan(
		&i.AvgCadence,
		&i.MinCadence,
		&i.MaxCadence,
		&i.ActivityCount,
	)
	return i, err
}

const getCadenceSummaryInRange = `-- name: GetCadenceSummaryInRange :one
SELECT 
    COALESCE(AVG(average_cadence), 0) as avg_cadence,
    COALESCE(MIN(average_cadence), 0) as min_cadence,
    COALESCE(MAX(average_cadence), 0) as max_cadence,
    COUNT(*) as activity_count
FROM activities 
WHERE start_date >= ? AND start_date <= ? AND average_cadence IS NOT NULL AND average_cadence > 0
`

type GetCadenceSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetCadenceSummaryInRangeRow struct {
	AvgCadence    interface{} `json:"avg_cadence"`
	MinCadence    interface{} `json:"min_cadence"`
	MaxCadence    interface{} `json:"max_cadence"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetCadenceSummaryInRange(ctx context.Context, arg GetCadenceSummaryInRangeParams) (GetCadenceSummaryInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getCadenceSummaryInRange, arg.StartDate, arg.StartDate_2)
	var i GetCadenceSummaryInRangeRow
	err := row.Scan(
		&i.AvgCadence,
		&i.MinCadence,
		&i.MaxCadence,
		&i.ActivityCount,
	)
	return i, err
}

const getCaloriesSummary = `-- name: GetCaloriesSummary :one

SELECT 
    COALESCE(SUM(calories), 0) as total_calories,
    COALESCE(AVG(calories), 0) as avg_calories,
    COALESCE(MIN(calories), 0) as min_calories,
    COALESCE(MAX(calories), 0) as max_calories,
    COUNT(*) as activity_count
FROM activities 
WHERE calories IS NOT NULL AND calories > 0
`

type GetCaloriesSummaryRow struct {
	TotalCalories interface{} `json:"total_calories"`
	AvgCalories   interface{} `json:"avg_calories"`
	MinCalories   interface{} `json:"min_calories"`
	MaxCalories   interface{} `json:"max_calories"`
	ActivityCount int64       `json:"activity_count"`
}

// Metrics aggregation queries
func (q *Queries) GetCaloriesSummary(ctx context.Context) (GetCaloriesSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getCaloriesSummary)
	var i GetCaloriesSummaryRow
	err := row.Scan(
		&i.TotalCalories,
		&i.AvgCalories,
		&i.MinCalories,
		&i.MaxCalories,
		&i.ActivityCount,
	)
	return i, err
}

const getCaloriesSummaryByType = `-- name: GetCaloriesSummaryByType :one
SELECT 
    COALESCE(SUM(calories), 0) as total_calories,
    COALESCE(AVG(calories), 0) as avg_calories,
    COALESCE(MIN(calories), 0) as min_calories,
    COALESCE(MAX(calories), 0) as max_calories,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND calories IS NOT NULL AND calories > 0
`

type GetCaloriesSummaryByTypeRow struct {
	TotalCalories interface{} `json:"total_calories"`
	AvgCalories   interface{} `json:"avg_calories"`
	MinCalories   interface{} `json:"min_calories"`
	MaxCalories   interface{} `json:"max_calories"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetCaloriesSummaryByType(ctx context.Context, type_ sql.NullString) (GetCaloriesSummaryByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, getCaloriesSummaryByType, type_)
	var i GetCaloriesSummaryByTypeRow
	err := row.Scan(
		&i.TotalCalories,
		&i.AvgCalories,
		&i.MinCalories,
		&i.MaxCalories,
		&i.ActivityCount,
	)
	return i, err
}

const getCaloriesSummaryByTypeInRange = `-- name: GetCaloriesSummaryByTypeInRange :one
SELECT 
    COALESCE(SUM(calories), 0) as total_calories,
    COALESCE(AVG(calories), 0) as avg_calories,
    COALESCE(MIN(calories), 0) as min_calories,
    COALESCE(MAX(calories), 0) as max_calories,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND start_date >= ? AND start_date <= ? AND calories IS NOT NULL AND calories > 0
`

type GetCaloriesSummaryByTypeInRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetCaloriesSummaryByTypeInRangeRow struct {
	TotalCalories interface{} `json:"total_calories"`
	AvgCalories   interface{} `json:"avg_calories"`
	MinCalories   interface{} `json:"min_calories"`
	MaxCalories   interface{} `json:"max_calories"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetCaloriesSummaryByTypeInRange(ctx context.Context, arg GetCaloriesSummaryByTypeInRangeParams) (GetCaloriesSummaryByTypeInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getCaloriesSummaryByTypeInRange, arg.Type, arg.StartDate, arg.StartDate_2)
	var i GetCaloriesSummaryByTypeInRangeRow
	err := row.Scan(
		&i.TotalCalories,
		&i.AvgCalories,
		&i.MinCalories,
		&i.MaxCalories,
		&i.ActivityCount,
	)
	return i, err
}

const getCaloriesSummaryInRange = `-- name: GetCaloriesSummaryInRange :one
SELECT 
    COALESCE(SUM(calories), 0) as total_calories,
    COALESCE(AVG(calories), 0) as avg_calories,
    COALESCE(MIN(calories), 0) as min_calories,
    COALESCE(MAX(calories), 0) as max_calories,
    COUNT(*) as activity_count
FROM activities 
WHERE start_date >= ? AND start_date <= ? AND calories IS NOT NULL AND calories > 0
`

type GetCaloriesSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetCaloriesSummaryInRangeRow struct {
	TotalCalories interface{} `json:"total_calories"`
	AvgCalories   interface{} `json:"avg_calories"`
	MinCalories   interface{} `json:"min_calories"`
	MaxCalories   interface{} `json:"max_calories"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetCaloriesSummaryInRange(ctx context.Context, arg GetCaloriesSummaryInRangeParams) (GetCaloriesSummaryInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getCaloriesSummaryInRange, arg.StartDate, arg.StartDate_2)
	var i GetCaloriesSummaryInRangeRow
	err := row.Scan(
		&i.TotalCalories,
		&i.AvgCalories,
		&i.MinCalories,
		&i.MaxCalories,
		&i.ActivityCount,
	)
	return i, err
}

const getDistanceSummary = `-- name: GetDistanceSummary :one
SELECT 
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(AVG(distance), 0) as avg_distance,
    COALESCE(MIN(distance), 0) as min_distance,
    COALESCE(MAX(distance), 0) as max_distance,
    COUNT(*) as activity_count
FROM activities 
WHERE distance IS NOT NULL AND distance > 0
`

type GetDistanceSummaryRow struct {
	TotalDistance interface{} `json:"total_distance"`
	AvgDistance   interface{} `json:"avg_distance"`
	MinDistance   interface{} `json:"min_distance"`
	MaxDistance   interface{} `json:"max_distance"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetDistanceSummary(ctx context.Context) (GetDistanceSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getDistanceSummary)
	var i GetDistanceSummaryRow
	err := row.Scan(
		&i.TotalDistance,
		&i.AvgDistance,
		&i.MinDistance,
		&i.MaxDistance,
		&i.ActivityCount,
	)
	return i, err
}

const getDistanceSummaryByType = `-- name: GetDistanceSummaryByType :one
SELECT 
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(AVG(distance), 0) as avg_distance,
    COALESCE(MIN(distance), 0) as min_distance,
    COALESCE(MAX(distance), 0) as max_distance,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND distance IS NOT NULL AND distance > 0
`

type GetDistanceSummaryByTypeRow struct {
	TotalDistance interface{} `json:"total_distance"`
	AvgDistance   interface{} `json:"avg_distance"`
	MinDistance   interface{} `json:"min_distance"`
	MaxDistance   interface{} `json:"max_distance"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetDistanceSummaryByType(ctx context.Context, type_ sql.NullString) (GetDistanceSummaryByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, getDistanceSummaryByType, type_)
	var i GetDistanceSummaryByTypeRow
	err := row.Scan(
		&i.TotalDistance,
		&i.AvgDistance,
		&i.MinDistance,
		&i.MaxDistance,
		&i.ActivityCount,
	)
	return i, err
}

const getDistanceSummaryByTypeInRange = `-- name: GetDistanceSummaryByTypeInRange :one
SELECT 
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(AVG(distance), 0) as avg_distance,
    COALESCE(MIN(distance), 0) as min_distance,
    COALESCE(MAX(distance), 0) as max_distance,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND start_date >= ? AND start_date <= ? AND distance IS NOT NULL AND distance > 0
`

type GetDistanceSummaryByTypeInRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetDistanceSummaryByTypeInRangeRow struct {
	TotalDistance interface{} `json:"total_distance"`
	AvgDistance   interface{} `json:"avg_distance"`
	MinDistance   interface{} `json:"min_distance"`
	MaxDistance   interface{} `json:"max_distance"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetDistanceSummaryByTypeInRange(ctx context.Context, arg GetDistanceSummaryByTypeInRangeParams) (GetDistanceSummaryByTypeInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getDistanceSummaryByTypeInRange, arg.Type, arg.StartDate, arg.StartDate_2)
	var i GetDistanceSummaryByTypeInRangeRow
	err := row.Scan(
		&i.TotalDistance,
		&i.AvgDistance,
		&i.MinDistance,
		&i.MaxDistance,
		&i.ActivityCount,
	)
	return i, err
}

const getDistanceSummaryInRange = `-- name: GetDistanceSummaryInRange :one
SELECT 
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(AVG(distance), 0) as avg_distance,
    COALESCE(MIN(distance), 0) as min_distance,
    COALESCE(MAX(distance), 0) as max_distance,
    COUNT(*) as activity_count
FROM activities 
WHERE start_date >= ? AND start_date <= ? AND distance IS NOT NULL AND distance > 0
`

type GetDistanceSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetDistanceSummaryInRangeRow struct {
	TotalDistance interface{} `json:"total_distance"`
	AvgDistance   interface{} `json:"avg_distance"`
	MinDistance   interface{} `json:"min_distance"`
	MaxDistance   interface{} `json:"max_distance"`
	ActivityCount int64       `json:"activity_count"`
}

func (q *Queries) GetDistanceSummaryInRange(ctx context.Context, arg GetDistanceSummaryInRangeParams) (GetDistanceSummaryInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getDistanceSummaryInRange, arg.StartDate, arg.StartDate_2)
	var i GetDistanceSummaryInRangeRow
	err := row.Scan(
		&i.TotalDistance,
		&i.AvgDistance,
		&i.MinDistance,
		&i.MaxDistance,
		&i.ActivityCount,
	)
	return i, err
}

const getDurationSummary = `-- name: GetDurationSummary :one
SELECT 
    COALESCE(SUM(moving_time), 0) as total_moving_time,
    COALESCE(AVG(moving_time), 0) as avg_moving_time,
    COALESCE(MIN(moving_time), 0) as min_moving_time,
    COALESCE(MAX(moving_time), 0) as max_moving_time,
    COUNT(*) as activity_count
FROM activities 
WHERE moving_time IS NOT NULL AND moving_time > 0
`

type GetDurationSummaryRow struct {
	TotalMovingTime interface{} `json:"total_moving_time"`
	AvgMovingTime   interface{} `json:"avg_moving_time"`
	MinMovingTime   interface{} `json:"min_moving_time"`
	MaxMovingTime   interface{} `json:"max_moving_time"`
	ActivityCount   int64       `json:"activity_count"`
}

func (q *Queries) GetDurationSummary(ctx context.Context) (GetDurationSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getDurationSummary)
	var i GetDurationSummaryRow
	err := row.Scan(
		&i.TotalMovingTime,
		&i.AvgMovingTime,
		&i.MinMovingTime,
		&i.MaxMovingTime,
		&i.ActivityCount,
	)
	return i, err
}

const getDurationSummaryByType = `-- name: GetDurationSummaryByType :one
SELECT 
    COALESCE(SUM(moving_time), 0) as total_moving_time,
    COALESCE(AVG(moving_time), 0) as avg_moving_time,
    COALESCE(MIN(moving_time), 0) as min_moving_time,
    COALESCE(MAX(moving_time), 0) as max_moving_time,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND moving_time IS NOT NULL AND moving_time > 0
`

type GetDurationSummaryByTypeRow struct {
	TotalMovingTime interface{} `json:"total_moving_time"`
	AvgMovingTime   interface{} `json:"avg_moving_time"`
	MinMovingTime   interface{} `json:"min_moving_time"`
	MaxMovingTime   interface{} `json:"max_moving_time"`
	ActivityCount   int64       `json:"activity_count"`
}

func (q *Queries) GetDurationSummaryByType(ctx context.Context, type_ sql.NullString) (GetDurationSummaryByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, getDurationSummaryByType, type_)
	var i GetDurationSummaryByTypeRow
	err := row.Scan(
		&i.TotalMovingTime,
		&i.AvgMovingTime,
		&i.MinMovingTime,
		&i.MaxMovingTime,
		&i.ActivityCount,
	)
	return i, err
}

const getDurationSummaryByTypeInRange = `-- name: GetDurationSummaryByTypeInRange :one
SELECT 
    COALESCE(SUM(moving_time), 0) as total_moving_time,
    COALESCE(AVG(moving_time), 0) as avg_moving_time,
    COALESCE(MIN(moving_time), 0) as min_moving_time,
    COALESCE(MAX(moving_time), 0) as max_moving_time,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND start_date >= ? AND start_date <= ? AND moving_time IS NOT NULL AND moving_time > 0
`

type GetDurationSummaryByTypeInRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetDurationSummaryByTypeInRangeRow struct {
	TotalMovingTime interface{} `json:"total_moving_time"`
	AvgMovingTime   interface{} `json:"avg_moving_time"`
	MinMovingTime   interface{} `json:"min_moving_time"`
	MaxMovingTime   interface{} `json:"max_moving_time"`
	ActivityCount   int64       `json:"activity_count"`
}

func (q *Queries) GetDurationSummaryByTypeInRange(ctx context.Context, arg GetDurationSummaryByTypeInRangeParams) (GetDurationSummaryByTypeInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getDurationSummaryByTypeInRange, arg.Type, arg.StartDate, arg.StartDate_2)
	var i GetDurationSummaryByTypeInRangeRow
	err := row.Scan(
		&i.TotalMovingTime,
		&i.AvgMovingTime,
		&i.MinMovingTime,
		&i.MaxMovingTime,
		&i.ActivityCount,
	)
	return i, err
}

const getDurationSummaryInRange = `-- name: GetDurationSummaryInRange :one
SELECT 
    COALESCE(SUM(moving_time), 0) as total_moving_time,
    COALESCE(AVG(moving_time), 0) as avg_moving_time,
    COALESCE(MIN(moving_time), 0) as min_moving_time,
    COALESCE(MAX(moving_time), 0) as max_moving_time,
    COUNT(*) as activity_count
FROM activities 
WHERE start_date >= ? AND start_date <= ? AND moving_time IS NOT NULL AND moving_time > 0
`

type GetDurationSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetDurationSummaryInRangeRow struct {
	TotalMovingTime interface{} `json:"total_moving_time"`
	AvgMovingTime   interface{} `json:"avg_moving_time"`
	MinMovingTime   interface{} `json:"min_moving_time"`
	MaxMovingTime   interface{} `json:"max_moving_time"`
	ActivityCount   int64       `json:"activity_count"`
}

func (q *Queries) GetDurationSummaryInRange(ctx context.Context, arg GetDurationSummaryInRangeParams) (GetDurationSummaryInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getDurationSummaryInRange, arg.StartDate, arg.StartDate_2)
	var i GetDurationSummaryInRangeRow
	err := row.Scan(
		&i.TotalMovingTime,
		&i.AvgMovingTime,
		&i.MinMovingTime,
		&i.MaxMovingTime,
		&i.ActivityCount,
	)
	return i, err
}

const getElevationSummary = `-- name: GetElevationSummary :one
SELECT 
    COALESCE(SUM(total_elevation_gain), 0) as total_elevation,
    COALESCE(AVG(total_elevation_gain), 0) as avg_elevation,
    COALESCE(MIN(total_elevation_gain), 0) as min_elevation,
    COALESCE(MAX(total_elevation_gain), 0) as max_elevation,
    COUNT(*) as activity_count
FROM activities 
WHERE total_elevation_gain IS NOT NULL AND total_elevation_gain > 0
`

type GetElevationSummaryRow struct {
	TotalElevation interface{} `json:"total_elevation"`
	AvgElevation   interface{} `json:"avg_elevation"`
	MinElevation   interface{} `json:"min_elevation"`
	MaxElevation   interface{} `json:"max_elevation"`
	ActivityCount  int64       `json:"activity_count"`
}

func (q *Queries) GetElevationSummary(ctx context.Context) (GetElevationSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getElevationSummary)
	var i GetElevationSummaryRow
	err := row.Scan(
		&i.TotalElevation,
		&i.AvgElevation,
		&i.MinElevation,
		&i.MaxElevation,
		&i.ActivityCount,
	)
	return i, err
}

const getElevationSummaryByType = `-- name: GetElevationSummaryByType :one
SELECT 
    COALESCE(SUM(total_elevation_gain), 0) as total_elevation,
    COALESCE(AVG(total_elevation_gain), 0) as avg_elevation,
    COALESCE(MIN(total_elevation_gain), 0) as min_elevation,
    COALESCE(MAX(total_elevation_gain), 0) as max_elevation,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND total_elevation_gain IS NOT NULL AND total_elevation_gain > 0
`

type GetElevationSummaryByTypeRow struct {
	TotalElevation interface{} `json:"total_elevation"`
	AvgElevation   interface{} `json:"avg_elevation"`
	MinElevation   interface{} `json:"min_elevation"`
	MaxElevation   interface{} `json:"max_elevation"`
	ActivityCount  int64       `json:"activity_count"`
}

func (q *Queries) GetElevationSummaryByType(ctx context.Context, type_ sql.NullString) (GetElevationSummaryByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, getElevationSummaryByType, type_)
	var i GetElevationSummaryByTypeRow
	err := row.Scan(
		&i.TotalElevation,
		&i.AvgElevation,
		&i.MinElevation,
		&i.MaxElevation,
		&i.ActivityCount,
	)
	return i, err
}

const getElevationSummaryByTypeInRange = `-- name: GetElevationSummaryByTypeInRange :one
SELECT 
    COALESCE(SUM(total_elevation_gain), 0) as total_elevation,
    COALESCE(AVG(total_elevation_gain), 0) as avg_elevation,
    COALESCE(MIN(total_elevation_gain), 0) as min_elevation,
    COALESCE(MAX(total_elevation_gain), 0) as max_elevation,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND start_date >= ? AND start_date <= ? AND total_elevation_gain IS NOT NULL AND total_elevation_gain > 0
`

type GetElevationSummaryByTypeInRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetElevationSummaryByTypeInRangeRow struct {
	TotalElevation interface{} `json:"total_elevation"`
	AvgElevation   interface{} `json:"avg_elevation"`
	MinElevation   interface{} `json:"min_elevation"`
	MaxElevation   interface{} `json:"max_elevation"`
	ActivityCount  int64       `json:"activity_count"`
}

func (q *Queries) GetElevationSummaryByTypeInRange(ctx context.Context, arg GetElevationSummaryByTypeInRangeParams) (GetElevationSummaryByTypeInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getElevationSummaryByTypeInRange, arg.Type, arg.StartDate, arg.StartDate_2)
	var i GetElevationSummaryByTypeInRangeRow
	err := row.Scan(
		&i.TotalElevation,
		&i.AvgElevation,
		&i.MinElevation,
		&i.MaxElevation,
		&i.ActivityCount,
	)
	return i, err
}

const getElevationSummaryInRange = `-- name: GetElevationSummaryInRange :one
SELECT 
    COALESCE(SUM(total_elevation_gain), 0) as total_elevation,
    COALESCE(AVG(total_elevation_gain), 0) as avg_elevation,
    COALESCE(MIN(total_elevation_gain), 0) as min_elevation,
    COALESCE(MAX(total_elevation_gain), 0) as max_elevation,
    COUNT(*) as activity_count
FROM activities 
WHERE start_date >= ? AND start_date <= ? AND total_elevation_gain IS NOT NULL AND total_elevation_gain > 0
`

type GetElevationSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetElevationSummaryInRangeRow struct {
	TotalElevation interface{} `json:"total_elevation"`
	AvgElevation   interface{} `json:"avg_elevation"`
	MinElevation   interface{} `json:"min_elevation"`
	MaxElevation   interface{} `json:"max_elevation"`
	ActivityCount  int64       `json:"activity_count"`
}

func (q *Queries) GetElevationSummaryInRange(ctx context.Context, arg GetElevationSummaryInRangeParams) (GetElevationSummaryInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getElevationSummaryInRange, arg.StartDate, arg.StartDate_2)
	var i GetElevationSummaryInRangeRow
	err := row.Scan(
		&i.TotalElevation,
		&i.AvgElevation,
		&i.MinElevation,
		&i.MaxElevation,
		&i.ActivityCount,
	)
	return i, err
}

const getFastestActivity = `-- name: GetFastestActivity :one

SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE average_speed IS NOT NULL AND average_speed > 0
ORDER BY average_speed DESC
LIMIT 1
`

// Personal records queries
func (q *Queries) GetFastestActivity(ctx context.Context) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getFastestActivity)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFastestActivityByType = `-- name: GetFastestActivityByType :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE type = ? AND average_speed IS NOT NULL AND average_speed > 0
ORDER BY average_speed DESC
LIMIT 1
`

func (q *Queries) GetFastestActivityByType(ctx context.Context, type_ sql.NullString) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getFastestActivityByType, type_)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHeartRateZoneSummary = `-- name: GetHeartRateZoneSummary :many
SELECT 
    zb.zone_number,
    SUM(zb.time_seconds) as total_time,
    AVG(zb.time_seconds) as avg_time,
    COUNT(*) as activity_count
FROM zone_buckets zb
JOIN activity_zones az ON zb.activity_zone_id = az.id
WHERE az.zone_type = 'heartrate'
GROUP BY zb.zone_number
ORDER BY zb.zone_number
`

type GetHeartRateZoneSummaryRow struct {
	ZoneNumber    int64           `json:"zone_number"`
	TotalTime     sql.NullFloat64 `json:"total_time"`
	AvgTime       sql.NullFloat64 `json:"avg_time"`
	ActivityCount int64           `json:"activity_count"`
}

func (q *Queries) GetHeartRateZoneSummary(ctx context.Context) ([]GetHeartRateZoneSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getHeartRateZoneSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHeartRateZoneSummaryRow{}
	for rows.Next() {
		var i GetHeartRateZoneSummaryRow
		if err := rows.Scan(
			&i.ZoneNumber,
			&i.TotalTime,
			&i.AvgTime,
			&i.ActivityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeartRateZoneSummaryByType = `-- name: GetHeartRateZoneSummaryByType :many
SELECT 
    zb.zone_number,
    SUM(zb.time_seconds) as total_time,
    AVG(zb.time_seconds) as avg_time,
    COUNT(*) as activity_count
FROM zone_buckets zb
JOIN activity_zones az ON zb.activity_zone_id = az.id
JOIN activities a ON az.activity_id = a.id
WHERE az.zone_type = 'heartrate' AND a.type = ?
GROUP BY zb.zone_number
ORDER BY zb.zone_number
`

type GetHeartRateZoneSummaryByTypeRow struct {
	ZoneNumber    int64           `json:"zone_number"`
	TotalTime     sql.NullFloat64 `json:"total_time"`
	AvgTime       sql.NullFloat64 `json:"avg_time"`
	ActivityCount int64           `json:"activity_count"`
}

func (q *Queries) GetHeartRateZoneSummaryByType(ctx context.Context, type_ sql.NullString) ([]GetHeartRateZoneSummaryByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getHeartRateZoneSummaryByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHeartRateZoneSummaryByTypeRow{}
	for rows.Next() {
		var i GetHeartRateZoneSummaryByTypeRow
		if err := rows.Scan(
			&i.ZoneNumber,
			&i.TotalTime,
			&i.AvgTime,
			&i.ActivityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeartRateZoneSummaryByTypeInRange = `-- name: GetHeartRateZoneSummaryByTypeInRange :many
SELECT 
    zb.zone_number,
    SUM(zb.time_seconds) as total_time,
    AVG(zb.time_seconds) as avg_time,
    COUNT(*) as activity_count
FROM zone_buckets zb
JOIN activity_zones az ON zb.activity_zone_id = az.id
JOIN activities a ON az.activity_id = a.id
WHERE az.zone_type = 'heartrate' AND a.type = ?
  AND a.start_date >= ? AND a.start_date <= ?
GROUP BY zb.zone_number
ORDER BY zb.zone_number
`

type GetHeartRateZoneSummaryByTypeInRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetHeartRateZoneSummaryByTypeInRangeRow struct {
	ZoneNumber    int64           `json:"zone_number"`
	TotalTime     sql.NullFloat64 `json:"total_time"`
	AvgTime       sql.NullFloat64 `json:"avg_time"`
	ActivityCount int64           `json:"activity_count"`
}

func (q *Queries) GetHeartRateZoneSummaryByTypeInRange(ctx context.Context, arg GetHeartRateZoneSummaryByTypeInRangeParams) ([]GetHeartRateZoneSummaryByTypeInRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getHeartRateZoneSummaryByTypeInRange, arg.Type, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHeartRateZoneSummaryByTypeInRangeRow{}
	for rows.Next() {
		var i GetHeartRateZoneSummaryByTypeInRangeRow
		if err := rows.Scan(
			&i.ZoneNumber,
			&i.TotalTime,
			&i.AvgTime,
			&i.ActivityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeartRateZoneSummaryInRange = `-- name: GetHeartRateZoneSummaryInRange :many
SELECT 
    zb.zone_number,
    SUM(zb.time_seconds) as total_time,
    AVG(zb.time_seconds) as avg_time,
    COUNT(*) as activity_count
FROM zone_buckets zb
JOIN activity_zones az ON zb.activity_zone_id = az.id
JOIN activities a ON az.activity_id = a.id
WHERE az.zone_type = 'heartrate' 
  AND a.start_date >= ? AND a.start_date <= ?
GROUP BY zb.zone_number
ORDER BY zb.zone_number
`

type GetHeartRateZoneSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetHeartRateZoneSummaryInRangeRow struct {
	ZoneNumber    int64           `json:"zone_number"`
	TotalTime     sql.NullFloat64 `json:"total_time"`
	AvgTime       sql.NullFloat64 `json:"avg_time"`
	ActivityCount int64           `json:"activity_count"`
}

func (q *Queries) GetHeartRateZoneSummaryInRange(ctx context.Context, arg GetHeartRateZoneSummaryInRangeParams) ([]GetHeartRateZoneSummaryInRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getHeartRateZoneSummaryInRange, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHeartRateZoneSummaryInRangeRow{}
	for rows.Next() {
		var i GetHeartRateZoneSummaryInRangeRow
		if err := rows.Scan(
			&i.ZoneNumber,
			&i.TotalTime,
			&i.AvgTime,
			&i.ActivityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeartrateSummary = `-- name: GetHeartrateSummary :one
SELECT 
    COALESCE(AVG(average_heartrate), 0) as avg_heartrate,
    COALESCE(MIN(average_heartrate), 0) as min_avg_heartrate,
    COALESCE(MAX(average_heartrate), 0) as max_avg_heartrate,
    COALESCE(MAX(max_heartrate), 0) as overall_max_heartrate,
    COUNT(*) as activity_count
FROM activities 
WHERE average_heartrate IS NOT NULL AND average_heartrate > 0
`

type GetHeartrateSummaryRow struct {
	AvgHeartrate        interface{} `json:"avg_heartrate"`
	MinAvgHeartrate     interface{} `json:"min_avg_heartrate"`
	MaxAvgHeartrate     interface{} `json:"max_avg_heartrate"`
	OverallMaxHeartrate interface{} `json:"overall_max_heartrate"`
	ActivityCount       int64       `json:"activity_count"`
}

func (q *Queries) GetHeartrateSummary(ctx context.Context) (GetHeartrateSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getHeartrateSummary)
	var i GetHeartrateSummaryRow
	err := row.Scan(
		&i.AvgHeartrate,
		&i.MinAvgHeartrate,
		&i.MaxAvgHeartrate,
		&i.OverallMaxHeartrate,
		&i.ActivityCount,
	)
	return i, err
}

const getHeartrateSummaryByType = `-- name: GetHeartrateSummaryByType :one
SELECT 
    COALESCE(AVG(average_heartrate), 0) as avg_heartrate,
    COALESCE(MIN(average_heartrate), 0) as min_avg_heartrate,
    COALESCE(MAX(average_heartrate), 0) as max_avg_heartrate,
    COALESCE(MAX(max_heartrate), 0) as overall_max_heartrate,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND average_heartrate IS NOT NULL AND average_heartrate > 0
`

type GetHeartrateSummaryByTypeRow struct {
	AvgHeartrate        interface{} `json:"avg_heartrate"`
	MinAvgHeartrate     interface{} `json:"min_avg_heartrate"`
	MaxAvgHeartrate     interface{} `json:"max_avg_heartrate"`
	OverallMaxHeartrate interface{} `json:"overall_max_heartrate"`
	ActivityCount       int64       `json:"activity_count"`
}

func (q *Queries) GetHeartrateSummaryByType(ctx context.Context, type_ sql.NullString) (GetHeartrateSummaryByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, getHeartrateSummaryByType, type_)
	var i GetHeartrateSummaryByTypeRow
	err := row.Scan(
		&i.AvgHeartrate,
		&i.MinAvgHeartrate,
		&i.MaxAvgHeartrate,
		&i.OverallMaxHeartrate,
		&i.ActivityCount,
	)
	return i, err
}

const getHeartrateSummaryByTypeInRange = `-- name: GetHeartrateSummaryByTypeInRange :one
SELECT 
    COALESCE(AVG(average_heartrate), 0) as avg_heartrate,
    COALESCE(MIN(average_heartrate), 0) as min_avg_heartrate,
    COALESCE(MAX(average_heartrate), 0) as max_avg_heartrate,
    COALESCE(MAX(max_heartrate), 0) as overall_max_heartrate,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND start_date >= ? AND start_date <= ? AND average_heartrate IS NOT NULL AND average_heartrate > 0
`

type GetHeartrateSummaryByTypeInRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetHeartrateSummaryByTypeInRangeRow struct {
	AvgHeartrate        interface{} `json:"avg_heartrate"`
	MinAvgHeartrate     interface{} `json:"min_avg_heartrate"`
	MaxAvgHeartrate     interface{} `json:"max_avg_heartrate"`
	OverallMaxHeartrate interface{} `json:"overall_max_heartrate"`
	ActivityCount       int64       `json:"activity_count"`
}

func (q *Queries) GetHeartrateSummaryByTypeInRange(ctx context.Context, arg GetHeartrateSummaryByTypeInRangeParams) (GetHeartrateSummaryByTypeInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getHeartrateSummaryByTypeInRange, arg.Type, arg.StartDate, arg.StartDate_2)
	var i GetHeartrateSummaryByTypeInRangeRow
	err := row.Scan(
		&i.AvgHeartrate,
		&i.MinAvgHeartrate,
		&i.MaxAvgHeartrate,
		&i.OverallMaxHeartrate,
		&i.ActivityCount,
	)
	return i, err
}

const getHeartrateSummaryInRange = `-- name: GetHeartrateSummaryInRange :one
SELECT 
    COALESCE(AVG(average_heartrate), 0) as avg_heartrate,
    COALESCE(MIN(average_heartrate), 0) as min_avg_heartrate,
    COALESCE(MAX(average_heartrate), 0) as max_avg_heartrate,
    COALESCE(MAX(max_heartrate), 0) as overall_max_heartrate,
    COUNT(*) as activity_count
FROM activities 
WHERE start_date >= ? AND start_date <= ? AND average_heartrate IS NOT NULL AND average_heartrate > 0
`

type GetHeartrateSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetHeartrateSummaryInRangeRow struct {
	AvgHeartrate        interface{} `json:"avg_heartrate"`
	MinAvgHeartrate     interface{} `json:"min_avg_heartrate"`
	MaxAvgHeartrate     interface{} `json:"max_avg_heartrate"`
	OverallMaxHeartrate interface{} `json:"overall_max_heartrate"`
	ActivityCount       int64       `json:"activity_count"`
}

func (q *Queries) GetHeartrateSummaryInRange(ctx context.Context, arg GetHeartrateSummaryInRangeParams) (GetHeartrateSummaryInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getHeartrateSummaryInRange, arg.StartDate, arg.StartDate_2)
	var i GetHeartrateSummaryInRangeRow
	err := row.Scan(
		&i.AvgHeartrate,
		&i.MinAvgHeartrate,
		&i.MaxAvgHeartrate,
		&i.OverallMaxHeartrate,
		&i.ActivityCount,
	)
	return i, err
}

const getHighestElevationActivity = `-- name: GetHighestElevationActivity :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE total_elevation_gain IS NOT NULL AND total_elevation_gain > 0
ORDER BY total_elevation_gain DESC
LIMIT 1
`

func (q *Queries) GetHighestElevationActivity(ctx context.Context) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getHighestElevationActivity)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHighestElevationActivityByType = `-- name: GetHighestElevationActivityByType :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE type = ? AND total_elevation_gain IS NOT NULL AND total_elevation_gain > 0
ORDER BY total_elevation_gain DESC
LIMIT 1
`

func (q *Queries) GetHighestElevationActivityByType(ctx context.Context, type_ sql.NullString) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getHighestElevationActivityByType, type_)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestActivity = `-- name: GetLatestActivity :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities ORDER BY start_date DESC LIMIT 1
`

func (q *Queries) GetLatestActivity(ctx context.Context) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getLatestActivity)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestActivityDate = `-- name: GetLatestActivityDate :one
SELECT MAX(start_date) as latest_date FROM activities
`

func (q *Queries) GetLatestActivityDate(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getLatestActivityDate)
	var latest_date interface{}
	err := row.Scan(&latest_date)
	return latest_date, err
}

const getLongestDistanceActivity = `-- name: GetLongestDistanceActivity :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE distance IS NOT NULL AND distance > 0
ORDER BY distance DESC
LIMIT 1
`

func (q *Queries) GetLongestDistanceActivity(ctx context.Context) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getLongestDistanceActivity)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLongestDistanceActivityByType = `-- name: GetLongestDistanceActivityByType :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE type = ? AND distance IS NOT NULL AND distance > 0
ORDER BY distance DESC
LIMIT 1
`

func (q *Queries) GetLongestDistanceActivityByType(ctx context.Context, type_ sql.NullString) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getLongestDistanceActivityByType, type_)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLongestDurationActivity = `-- name: GetLongestDurationActivity :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE moving_time IS NOT NULL AND moving_time > 0
ORDER BY moving_time DESC
LIMIT 1
`

func (q *Queries) GetLongestDurationActivity(ctx context.Context) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getLongestDurationActivity)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLongestDurationActivityByType = `-- name: GetLongestDurationActivityByType :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE type = ? AND moving_time IS NOT NULL AND moving_time > 0
ORDER BY moving_time DESC
LIMIT 1
`

func (q *Queries) GetLongestDurationActivityByType(ctx context.Context, type_ sql.NullString) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getLongestDurationActivityByType, type_)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMostCaloriesActivity = `-- name: GetMostCaloriesActivity :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE calories IS NOT NULL AND calories > 0
ORDER BY calories DESC
LIMIT 1
`

func (q *Queries) GetMostCaloriesActivity(ctx context.Context) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getMostCaloriesActivity)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMostCaloriesActivityByType = `-- name: GetMostCaloriesActivityByType :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE type = ? AND calories IS NOT NULL AND calories > 0
ORDER BY calories DESC
LIMIT 1
`

func (q *Queries) GetMostCaloriesActivityByType(ctx context.Context, type_ sql.NullString) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getMostCaloriesActivityByType, type_)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOldestActivity = `-- name: GetOldestActivity :one
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities ORDER BY start_date ASC LIMIT 1
`

func (q *Queries) GetOldestActivity(ctx context.Context) (Activity, error) {
	row := q.db.QueryRowContext(ctx, getOldestActivity)
	var i Activity
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Distance,
		&i.MovingTime,
		&i.ElapsedTime,
		&i.TotalElevationGain,
		&i.Type,
		&i.SportType,
		&i.StartDate,
		&i.StartDateLocal,
		&i.Timezone,
		&i.AverageSpeed,
		&i.MaxSpeed,
		&i.AverageCadence,
		&i.AverageHeartrate,
		&i.MaxHeartrate,
		&i.Calories,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOldestActivityDate = `-- name: GetOldestActivityDate :one
SELECT MIN(start_date) as oldest_date FROM activities
`

func (q *Queries) GetOldestActivityDate(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getOldestActivityDate)
	var oldest_date interface{}
	err := row.Scan(&oldest_date)
	return oldest_date, err
}

const getPeriodStats = `-- name: GetPeriodStats :one

SELECT
    COUNT(*) as activity_count,
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(SUM(moving_time), 0) as total_moving_time,
    COALESCE(AVG(average_speed), 0) as avg_speed
FROM activities
WHERE start_date >= ? AND start_date <= ?
`

type GetPeriodStatsParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetPeriodStatsRow struct {
	ActivityCount   int64       `json:"activity_count"`
	TotalDistance   interface{} `json:"total_distance"`
	TotalMovingTime interface{} `json:"total_moving_time"`
	AvgSpeed        interface{} `json:"avg_speed"`
}

// Period comparison queries with detailed metrics
func (q *Queries) GetPeriodStats(ctx context.Context, arg GetPeriodStatsParams) (GetPeriodStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getPeriodStats, arg.StartDate, arg.StartDate_2)
	var i GetPeriodStatsRow
	err := row.Scan(
		&i.ActivityCount,
		&i.TotalDistance,
		&i.TotalMovingTime,
		&i.AvgSpeed,
	)
	return i, err
}

const getPeriodStatsByType = `-- name: GetPeriodStatsByType :one
SELECT
    COUNT(*) as activity_count,
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(SUM(moving_time), 0) as total_moving_time,
    COALESCE(AVG(average_speed), 0) as avg_speed
FROM activities
WHERE type = ? AND start_date >= ? AND start_date <= ?
`

type GetPeriodStatsByTypeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetPeriodStatsByTypeRow struct {
	ActivityCount   int64       `json:"activity_count"`
	TotalDistance   interface{} `json:"total_distance"`
	TotalMovingTime interface{} `json:"total_moving_time"`
	AvgSpeed        interface{} `json:"avg_speed"`
}

func (q *Queries) GetPeriodStatsByType(ctx context.Context, arg GetPeriodStatsByTypeParams) (GetPeriodStatsByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, getPeriodStatsByType, arg.Type, arg.StartDate, arg.StartDate_2)
	var i GetPeriodStatsByTypeRow
	err := row.Scan(
		&i.ActivityCount,
		&i.TotalDistance,
		&i.TotalMovingTime,
		&i.AvgSpeed,
	)
	return i, err
}

const getPowerZoneSummary = `-- name: GetPowerZoneSummary :many
SELECT 
    zb.zone_number,
    SUM(zb.time_seconds) as total_time,
    AVG(zb.time_seconds) as avg_time,
    COUNT(*) as activity_count
FROM zone_buckets zb
JOIN activity_zones az ON zb.activity_zone_id = az.id
WHERE az.zone_type = 'power'
GROUP BY zb.zone_number
ORDER BY zb.zone_number
`

type GetPowerZoneSummaryRow struct {
	ZoneNumber    int64           `json:"zone_number"`
	TotalTime     sql.NullFloat64 `json:"total_time"`
	AvgTime       sql.NullFloat64 `json:"avg_time"`
	ActivityCount int64           `json:"activity_count"`
}

func (q *Queries) GetPowerZoneSummary(ctx context.Context) ([]GetPowerZoneSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getPowerZoneSummary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPowerZoneSummaryRow{}
	for rows.Next() {
		var i GetPowerZoneSummaryRow
		if err := rows.Scan(
			&i.ZoneNumber,
			&i.TotalTime,
			&i.AvgTime,
			&i.ActivityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPowerZoneSummaryByType = `-- name: GetPowerZoneSummaryByType :many
SELECT 
    zb.zone_number,
    SUM(zb.time_seconds) as total_time,
    AVG(zb.time_seconds) as avg_time,
    COUNT(*) as activity_count
FROM zone_buckets zb
JOIN activity_zones az ON zb.activity_zone_id = az.id
JOIN activities a ON az.activity_id = a.id
WHERE az.zone_type = 'power' AND a.type = ?
GROUP BY zb.zone_number
ORDER BY zb.zone_number
`

type GetPowerZoneSummaryByTypeRow struct {
	ZoneNumber    int64           `json:"zone_number"`
	TotalTime     sql.NullFloat64 `json:"total_time"`
	AvgTime       sql.NullFloat64 `json:"avg_time"`
	ActivityCount int64           `json:"activity_count"`
}

func (q *Queries) GetPowerZoneSummaryByType(ctx context.Context, type_ sql.NullString) ([]GetPowerZoneSummaryByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getPowerZoneSummaryByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPowerZoneSummaryByTypeRow{}
	for rows.Next() {
		var i GetPowerZoneSummaryByTypeRow
		if err := rows.Scan(
			&i.ZoneNumber,
			&i.TotalTime,
			&i.AvgTime,
			&i.ActivityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPowerZoneSummaryInRange = `-- name: GetPowerZoneSummaryInRange :many
SELECT
    zb.zone_number,
    SUM(zb.time_seconds) as total_time,
    AVG(zb.time_seconds) as avg_time,
    COUNT(*) as activity_count
FROM zone_buckets zb
JOIN activity_zones az ON zb.activity_zone_id = az.id
JOIN activities a ON az.activity_id = a.id
WHERE az.zone_type = 'power'
  AND a.start_date >= ? AND a.start_date <= ?
GROUP BY zb.zone_number
ORDER BY zb.zone_number
`

type GetPowerZoneSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetPowerZoneSummaryInRangeRow struct {
	ZoneNumber    int64           `json:"zone_number"`
	TotalTime     sql.NullFloat64 `json:"total_time"`
	AvgTime       sql.NullFloat64 `json:"avg_time"`
	ActivityCount int64           `json:"activity_count"`
}

func (q *Queries) GetPowerZoneSummaryInRange(ctx context.Context, arg GetPowerZoneSummaryInRangeParams) ([]GetPowerZoneSummaryInRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getPowerZoneSummaryInRange, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPowerZoneSummaryInRangeRow{}
	for rows.Next() {
		var i GetPowerZoneSummaryInRangeRow
		if err := rows.Scan(
			&i.ZoneNumber,
			&i.TotalTime,
			&i.AvgTime,
			&i.ActivityCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentActivities = `-- name: GetRecentActivities :many
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities ORDER BY start_date DESC LIMIT ?
`

func (q *Queries) GetRecentActivities(ctx context.Context, limit int64) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, getRecentActivities, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.Type,
			&i.SportType,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageCadence,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.Calories,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpeedSummary = `-- name: GetSpeedSummary :one
SELECT 
    COALESCE(AVG(average_speed), 0) as avg_speed,
    COALESCE(MIN(average_speed), 0) as min_avg_speed,
    COALESCE(MAX(average_speed), 0) as max_avg_speed,
    COALESCE(MAX(max_speed), 0) as overall_max_speed,
    COUNT(*) as activity_count
FROM activities 
WHERE average_speed IS NOT NULL AND average_speed > 0
`

type GetSpeedSummaryRow struct {
	AvgSpeed        interface{} `json:"avg_speed"`
	MinAvgSpeed     interface{} `json:"min_avg_speed"`
	MaxAvgSpeed     interface{} `json:"max_avg_speed"`
	OverallMaxSpeed interface{} `json:"overall_max_speed"`
	ActivityCount   int64       `json:"activity_count"`
}

func (q *Queries) GetSpeedSummary(ctx context.Context) (GetSpeedSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getSpeedSummary)
	var i GetSpeedSummaryRow
	err := row.Scan(
		&i.AvgSpeed,
		&i.MinAvgSpeed,
		&i.MaxAvgSpeed,
		&i.OverallMaxSpeed,
		&i.ActivityCount,
	)
	return i, err
}

const getSpeedSummaryByType = `-- name: GetSpeedSummaryByType :one
SELECT 
    COALESCE(AVG(average_speed), 0) as avg_speed,
    COALESCE(MIN(average_speed), 0) as min_avg_speed,
    COALESCE(MAX(average_speed), 0) as max_avg_speed,
    COALESCE(MAX(max_speed), 0) as overall_max_speed,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND average_speed IS NOT NULL AND average_speed > 0
`

type GetSpeedSummaryByTypeRow struct {
	AvgSpeed        interface{} `json:"avg_speed"`
	MinAvgSpeed     interface{} `json:"min_avg_speed"`
	MaxAvgSpeed     interface{} `json:"max_avg_speed"`
	OverallMaxSpeed interface{} `json:"overall_max_speed"`
	ActivityCount   int64       `json:"activity_count"`
}

func (q *Queries) GetSpeedSummaryByType(ctx context.Context, type_ sql.NullString) (GetSpeedSummaryByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, getSpeedSummaryByType, type_)
	var i GetSpeedSummaryByTypeRow
	err := row.Scan(
		&i.AvgSpeed,
		&i.MinAvgSpeed,
		&i.MaxAvgSpeed,
		&i.OverallMaxSpeed,
		&i.ActivityCount,
	)
	return i, err
}

const getSpeedSummaryByTypeInRange = `-- name: GetSpeedSummaryByTypeInRange :one
SELECT 
    COALESCE(AVG(average_speed), 0) as avg_speed,
    COALESCE(MIN(average_speed), 0) as min_avg_speed,
    COALESCE(MAX(average_speed), 0) as max_avg_speed,
    COALESCE(MAX(max_speed), 0) as overall_max_speed,
    COUNT(*) as activity_count
FROM activities 
WHERE type = ? AND start_date >= ? AND start_date <= ? AND average_speed IS NOT NULL AND average_speed > 0
`

type GetSpeedSummaryByTypeInRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetSpeedSummaryByTypeInRangeRow struct {
	AvgSpeed        interface{} `json:"avg_speed"`
	MinAvgSpeed     interface{} `json:"min_avg_speed"`
	MaxAvgSpeed     interface{} `json:"max_avg_speed"`
	OverallMaxSpeed interface{} `json:"overall_max_speed"`
	ActivityCount   int64       `json:"activity_count"`
}

func (q *Queries) GetSpeedSummaryByTypeInRange(ctx context.Context, arg GetSpeedSummaryByTypeInRangeParams) (GetSpeedSummaryByTypeInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getSpeedSummaryByTypeInRange, arg.Type, arg.StartDate, arg.StartDate_2)
	var i GetSpeedSummaryByTypeInRangeRow
	err := row.Scan(
		&i.AvgSpeed,
		&i.MinAvgSpeed,
		&i.MaxAvgSpeed,
		&i.OverallMaxSpeed,
		&i.ActivityCount,
	)
	return i, err
}

const getSpeedSummaryInRange = `-- name: GetSpeedSummaryInRange :one
SELECT 
    COALESCE(AVG(average_speed), 0) as avg_speed,
    COALESCE(MIN(average_speed), 0) as min_avg_speed,
    COALESCE(MAX(average_speed), 0) as max_avg_speed,
    COALESCE(MAX(max_speed), 0) as overall_max_speed,
    COUNT(*) as activity_count
FROM activities 
WHERE start_date >= ? AND start_date <= ? AND average_speed IS NOT NULL AND average_speed > 0
`

type GetSpeedSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetSpeedSummaryInRangeRow struct {
	AvgSpeed        interface{} `json:"avg_speed"`
	MinAvgSpeed     interface{} `json:"min_avg_speed"`
	MaxAvgSpeed     interface{} `json:"max_avg_speed"`
	OverallMaxSpeed interface{} `json:"overall_max_speed"`
	ActivityCount   int64       `json:"activity_count"`
}

func (q *Queries) GetSpeedSummaryInRange(ctx context.Context, arg GetSpeedSummaryInRangeParams) (GetSpeedSummaryInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getSpeedSummaryInRange, arg.StartDate, arg.StartDate_2)
	var i GetSpeedSummaryInRangeRow
	err := row.Scan(
		&i.AvgSpeed,
		&i.MinAvgSpeed,
		&i.MaxAvgSpeed,
		&i.OverallMaxSpeed,
		&i.ActivityCount,
	)
	return i, err
}

const getTrainingSummary = `-- name: GetTrainingSummary :one

SELECT
    COUNT(*) as activity_count,
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(SUM(moving_time), 0) as total_moving_time,
    COALESCE(AVG(average_speed), 0) as avg_speed,
    COALESCE(AVG(average_heartrate), 0) as avg_heartrate,
    COALESCE(SUM(calories), 0) as total_calories,
    COALESCE(SUM(total_elevation_gain), 0) as total_elevation
FROM activities
`

type GetTrainingSummaryRow struct {
	ActivityCount   int64       `json:"activity_count"`
	TotalDistance   interface{} `json:"total_distance"`
	TotalMovingTime interface{} `json:"total_moving_time"`
	AvgSpeed        interface{} `json:"avg_speed"`
	AvgHeartrate    interface{} `json:"avg_heartrate"`
	TotalCalories   interface{} `json:"total_calories"`
	TotalElevation  interface{} `json:"total_elevation"`
}

// Training summary queries
func (q *Queries) GetTrainingSummary(ctx context.Context) (GetTrainingSummaryRow, error) {
	row := q.db.QueryRowContext(ctx, getTrainingSummary)
	var i GetTrainingSummaryRow
	err := row.Scan(
		&i.ActivityCount,
		&i.TotalDistance,
		&i.TotalMovingTime,
		&i.AvgSpeed,
		&i.AvgHeartrate,
		&i.TotalCalories,
		&i.TotalElevation,
	)
	return i, err
}

const getTrainingSummaryByType = `-- name: GetTrainingSummaryByType :one
SELECT
    COUNT(*) as activity_count,
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(SUM(moving_time), 0) as total_moving_time,
    COALESCE(AVG(average_speed), 0) as avg_speed,
    COALESCE(AVG(average_heartrate), 0) as avg_heartrate,
    COALESCE(SUM(calories), 0) as total_calories,
    COALESCE(SUM(total_elevation_gain), 0) as total_elevation
FROM activities
WHERE type = ?
`

type GetTrainingSummaryByTypeRow struct {
	ActivityCount   int64       `json:"activity_count"`
	TotalDistance   interface{} `json:"total_distance"`
	TotalMovingTime interface{} `json:"total_moving_time"`
	AvgSpeed        interface{} `json:"avg_speed"`
	AvgHeartrate    interface{} `json:"avg_heartrate"`
	TotalCalories   interface{} `json:"total_calories"`
	TotalElevation  interface{} `json:"total_elevation"`
}

func (q *Queries) GetTrainingSummaryByType(ctx context.Context, type_ sql.NullString) (GetTrainingSummaryByTypeRow, error) {
	row := q.db.QueryRowContext(ctx, getTrainingSummaryByType, type_)
	var i GetTrainingSummaryByTypeRow
	err := row.Scan(
		&i.ActivityCount,
		&i.TotalDistance,
		&i.TotalMovingTime,
		&i.AvgSpeed,
		&i.AvgHeartrate,
		&i.TotalCalories,
		&i.TotalElevation,
	)
	return i, err
}

const getTrainingSummaryByTypeInRange = `-- name: GetTrainingSummaryByTypeInRange :one
SELECT
    COUNT(*) as activity_count,
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(SUM(moving_time), 0) as total_moving_time,
    COALESCE(AVG(average_speed), 0) as avg_speed,
    COALESCE(AVG(average_heartrate), 0) as avg_heartrate,
    COALESCE(SUM(calories), 0) as total_calories,
    COALESCE(SUM(total_elevation_gain), 0) as total_elevation
FROM activities
WHERE type = ? AND start_date >= ? AND start_date <= ?
`

type GetTrainingSummaryByTypeInRangeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetTrainingSummaryByTypeInRangeRow struct {
	ActivityCount   int64       `json:"activity_count"`
	TotalDistance   interface{} `json:"total_distance"`
	TotalMovingTime interface{} `json:"total_moving_time"`
	AvgSpeed        interface{} `json:"avg_speed"`
	AvgHeartrate    interface{} `json:"avg_heartrate"`
	TotalCalories   interface{} `json:"total_calories"`
	TotalElevation  interface{} `json:"total_elevation"`
}

func (q *Queries) GetTrainingSummaryByTypeInRange(ctx context.Context, arg GetTrainingSummaryByTypeInRangeParams) (GetTrainingSummaryByTypeInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getTrainingSummaryByTypeInRange, arg.Type, arg.StartDate, arg.StartDate_2)
	var i GetTrainingSummaryByTypeInRangeRow
	err := row.Scan(
		&i.ActivityCount,
		&i.TotalDistance,
		&i.TotalMovingTime,
		&i.AvgSpeed,
		&i.AvgHeartrate,
		&i.TotalCalories,
		&i.TotalElevation,
	)
	return i, err
}

const getTrainingSummaryInRange = `-- name: GetTrainingSummaryInRange :one
SELECT
    COUNT(*) as activity_count,
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(SUM(moving_time), 0) as total_moving_time,
    COALESCE(AVG(average_speed), 0) as avg_speed,
    COALESCE(AVG(average_heartrate), 0) as avg_heartrate,
    COALESCE(SUM(calories), 0) as total_calories,
    COALESCE(SUM(total_elevation_gain), 0) as total_elevation
FROM activities
WHERE start_date >= ? AND start_date <= ?
`

type GetTrainingSummaryInRangeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetTrainingSummaryInRangeRow struct {
	ActivityCount   int64       `json:"activity_count"`
	TotalDistance   interface{} `json:"total_distance"`
	TotalMovingTime interface{} `json:"total_moving_time"`
	AvgSpeed        interface{} `json:"avg_speed"`
	AvgHeartrate    interface{} `json:"avg_heartrate"`
	TotalCalories   interface{} `json:"total_calories"`
	TotalElevation  interface{} `json:"total_elevation"`
}

func (q *Queries) GetTrainingSummaryInRange(ctx context.Context, arg GetTrainingSummaryInRangeParams) (GetTrainingSummaryInRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getTrainingSummaryInRange, arg.StartDate, arg.StartDate_2)
	var i GetTrainingSummaryInRangeRow
	err := row.Scan(
		&i.ActivityCount,
		&i.TotalDistance,
		&i.TotalMovingTime,
		&i.AvgSpeed,
		&i.AvgHeartrate,
		&i.TotalCalories,
		&i.TotalElevation,
	)
	return i, err
}

const getWeeklyVolume = `-- name: GetWeeklyVolume :many

SELECT
    strftime('%Y-W%W', start_date) as week,
    COUNT(*) as activity_count,
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(SUM(moving_time), 0) as total_duration,
    COALESCE(SUM(calories), 0) as total_calories,
    COALESCE(SUM(total_elevation_gain), 0) as total_elevation
FROM activities
WHERE start_date >= ? AND start_date <= ?
GROUP BY strftime('%Y-W%W', start_date)
ORDER BY week DESC
`

type GetWeeklyVolumeParams struct {
	StartDate   sql.NullTime `json:"start_date"`
	StartDate_2 sql.NullTime `json:"start_date_2"`
}

type GetWeeklyVolumeRow struct {
	Week           interface{} `json:"week"`
	ActivityCount  int64       `json:"activity_count"`
	TotalDistance  interface{} `json:"total_distance"`
	TotalDuration  interface{} `json:"total_duration"`
	TotalCalories  interface{} `json:"total_calories"`
	TotalElevation interface{} `json:"total_elevation"`
}

// Weekly volume queries for training load analysis
func (q *Queries) GetWeeklyVolume(ctx context.Context, arg GetWeeklyVolumeParams) ([]GetWeeklyVolumeRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeeklyVolume, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWeeklyVolumeRow{}
	for rows.Next() {
		var i GetWeeklyVolumeRow
		if err := rows.Scan(
			&i.Week,
			&i.ActivityCount,
			&i.TotalDistance,
			&i.TotalDuration,
			&i.TotalCalories,
			&i.TotalElevation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyVolumeByType = `-- name: GetWeeklyVolumeByType :many
SELECT
    strftime('%Y-W%W', start_date) as week,
    COUNT(*) as activity_count,
    COALESCE(SUM(distance), 0) as total_distance,
    COALESCE(SUM(moving_time), 0) as total_duration,
    COALESCE(SUM(calories), 0) as total_calories,
    COALESCE(SUM(total_elevation_gain), 0) as total_elevation
FROM activities
WHERE type = ? AND start_date >= ? AND start_date <= ?
GROUP BY strftime('%Y-W%W', start_date)
ORDER BY week DESC
`

type GetWeeklyVolumeByTypeParams struct {
	Type        sql.NullString `json:"type"`
	StartDate   sql.NullTime   `json:"start_date"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
}

type GetWeeklyVolumeByTypeRow struct {
	Week           interface{} `json:"week"`
	ActivityCount  int64       `json:"activity_count"`
	TotalDistance  interface{} `json:"total_distance"`
	TotalDuration  interface{} `json:"total_duration"`
	TotalCalories  interface{} `json:"total_calories"`
	TotalElevation interface{} `json:"total_elevation"`
}

func (q *Queries) GetWeeklyVolumeByType(ctx context.Context, arg GetWeeklyVolumeByTypeParams) ([]GetWeeklyVolumeByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeeklyVolumeByType, arg.Type, arg.StartDate, arg.StartDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWeeklyVolumeByTypeRow{}
	for rows.Next() {
		var i GetWeeklyVolumeByTypeRow
		if err := rows.Scan(
			&i.Week,
			&i.ActivityCount,
			&i.TotalDistance,
			&i.TotalDuration,
			&i.TotalCalories,
			&i.TotalElevation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getZoneBuckets = `-- name: GetZoneBuckets :many
SELECT id, activity_zone_id, zone_number, min_value, max_value, time_seconds FROM zone_buckets WHERE activity_zone_id = ? ORDER BY zone_number
`

func (q *Queries) GetZoneBuckets(ctx context.Context, activityZoneID int64) ([]ZoneBucket, error) {
	rows, err := q.db.QueryContext(ctx, getZoneBuckets, activityZoneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ZoneBucket{}
	for rows.Next() {
		var i ZoneBucket
		if err := rows.Scan(
			&i.ID,
			&i.ActivityZoneID,
			&i.ZoneNumber,
			&i.MinValue,
			&i.MaxValue,
			&i.TimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveAuthConfig = `-- name: SaveAuthConfig :exec

INSERT INTO auth_config (id, client_id, client_secret, access_token, refresh_token, expires_at, updated_at)
VALUES (1, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(id) DO UPDATE SET
    client_id = excluded.client_id,
    client_secret = excluded.client_secret,
    access_token = excluded.access_token,
    refresh_token = excluded.refresh_token,
    expires_at = excluded.expires_at,
    updated_at = CURRENT_TIMESTAMP
`

type SaveAuthConfigParams struct {
	ClientID     string         `json:"client_id"`
	ClientSecret string         `json:"client_secret"`
	AccessToken  sql.NullString `json:"access_token"`
	RefreshToken sql.NullString `json:"refresh_token"`
	ExpiresAt    sql.NullInt64  `json:"expires_at"`
}

// Auth config queries
func (q *Queries) SaveAuthConfig(ctx context.Context, arg SaveAuthConfigParams) error {
	_, err := q.db.ExecContext(ctx, saveAuthConfig,
		arg.ClientID,
		arg.ClientSecret,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
	)
	return err
}

const searchActivities = `-- name: SearchActivities :many

SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE (? IS NULL OR type = ?)
  AND (? IS NULL OR start_date >= ?)
  AND (? IS NULL OR start_date <= ?)
ORDER BY start_date DESC
LIMIT ?
`

type SearchActivitiesParams struct {
	Column1     interface{}    `json:"column_1"`
	Type        sql.NullString `json:"type"`
	Column3     interface{}    `json:"column_3"`
	StartDate   sql.NullTime   `json:"start_date"`
	Column5     interface{}    `json:"column_5"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
	Limit       int64          `json:"limit"`
}

// Flexible activity search with sorting
func (q *Queries) SearchActivities(ctx context.Context, arg SearchActivitiesParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, searchActivities,
		arg.Column1,
		arg.Type,
		arg.Column3,
		arg.StartDate,
		arg.Column5,
		arg.StartDate_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.Type,
			&i.SportType,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageCadence,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.Calories,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchActivitiesByDistance = `-- name: SearchActivitiesByDistance :many
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE (? IS NULL OR type = ?)
  AND (? IS NULL OR start_date >= ?)
  AND (? IS NULL OR start_date <= ?)
  AND distance IS NOT NULL
ORDER BY distance DESC
LIMIT ?
`

type SearchActivitiesByDistanceParams struct {
	Column1     interface{}    `json:"column_1"`
	Type        sql.NullString `json:"type"`
	Column3     interface{}    `json:"column_3"`
	StartDate   sql.NullTime   `json:"start_date"`
	Column5     interface{}    `json:"column_5"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
	Limit       int64          `json:"limit"`
}

func (q *Queries) SearchActivitiesByDistance(ctx context.Context, arg SearchActivitiesByDistanceParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, searchActivitiesByDistance,
		arg.Column1,
		arg.Type,
		arg.Column3,
		arg.StartDate,
		arg.Column5,
		arg.StartDate_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.Type,
			&i.SportType,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageCadence,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.Calories,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchActivitiesByDuration = `-- name: SearchActivitiesByDuration :many
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE (? IS NULL OR type = ?)
  AND (? IS NULL OR start_date >= ?)
  AND (? IS NULL OR start_date <= ?)
  AND moving_time IS NOT NULL
ORDER BY moving_time DESC
LIMIT ?
`

type SearchActivitiesByDurationParams struct {
	Column1     interface{}    `json:"column_1"`
	Type        sql.NullString `json:"type"`
	Column3     interface{}    `json:"column_3"`
	StartDate   sql.NullTime   `json:"start_date"`
	Column5     interface{}    `json:"column_5"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
	Limit       int64          `json:"limit"`
}

func (q *Queries) SearchActivitiesByDuration(ctx context.Context, arg SearchActivitiesByDurationParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, searchActivitiesByDuration,
		arg.Column1,
		arg.Type,
		arg.Column3,
		arg.StartDate,
		arg.Column5,
		arg.StartDate_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.Type,
			&i.SportType,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageCadence,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.Calories,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchActivitiesByElevation = `-- name: SearchActivitiesByElevation :many
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE (? IS NULL OR type = ?)
  AND (? IS NULL OR start_date >= ?)
  AND (? IS NULL OR start_date <= ?)
  AND total_elevation_gain IS NOT NULL
ORDER BY total_elevation_gain DESC
LIMIT ?
`

type SearchActivitiesByElevationParams struct {
	Column1     interface{}    `json:"column_1"`
	Type        sql.NullString `json:"type"`
	Column3     interface{}    `json:"column_3"`
	StartDate   sql.NullTime   `json:"start_date"`
	Column5     interface{}    `json:"column_5"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
	Limit       int64          `json:"limit"`
}

func (q *Queries) SearchActivitiesByElevation(ctx context.Context, arg SearchActivitiesByElevationParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, searchActivitiesByElevation,
		arg.Column1,
		arg.Type,
		arg.Column3,
		arg.StartDate,
		arg.Column5,
		arg.StartDate_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.Type,
			&i.SportType,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageCadence,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.Calories,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchActivitiesBySpeed = `-- name: SearchActivitiesBySpeed :many
SELECT id, name, distance, moving_time, elapsed_time, total_elevation_gain, type, sport_type, start_date, start_date_local, timezone, average_speed, max_speed, average_cadence, average_heartrate, max_heartrate, calories, created_at, updated_at FROM activities
WHERE (? IS NULL OR type = ?)
  AND (? IS NULL OR start_date >= ?)
  AND (? IS NULL OR start_date <= ?)
  AND average_speed IS NOT NULL
ORDER BY average_speed DESC
LIMIT ?
`

type SearchActivitiesBySpeedParams struct {
	Column1     interface{}    `json:"column_1"`
	Type        sql.NullString `json:"type"`
	Column3     interface{}    `json:"column_3"`
	StartDate   sql.NullTime   `json:"start_date"`
	Column5     interface{}    `json:"column_5"`
	StartDate_2 sql.NullTime   `json:"start_date_2"`
	Limit       int64          `json:"limit"`
}

func (q *Queries) SearchActivitiesBySpeed(ctx context.Context, arg SearchActivitiesBySpeedParams) ([]Activity, error) {
	rows, err := q.db.QueryContext(ctx, searchActivitiesBySpeed,
		arg.Column1,
		arg.Type,
		arg.Column3,
		arg.StartDate,
		arg.Column5,
		arg.StartDate_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Activity{}
	for rows.Next() {
		var i Activity
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Distance,
			&i.MovingTime,
			&i.ElapsedTime,
			&i.TotalElevationGain,
			&i.Type,
			&i.SportType,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Timezone,
			&i.AverageSpeed,
			&i.MaxSpeed,
			&i.AverageCadence,
			&i.AverageHeartrate,
			&i.MaxHeartrate,
			&i.Calories,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTokens = `-- name: UpdateTokens :exec
UPDATE auth_config SET
    access_token = ?,
    refresh_token = ?,
    expires_at = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = 1
`

type UpdateTokensParams struct {
	AccessToken  sql.NullString `json:"access_token"`
	RefreshToken sql.NullString `json:"refresh_token"`
	ExpiresAt    sql.NullInt64  `json:"expires_at"`
}

func (q *Queries) UpdateTokens(ctx context.Context, arg UpdateTokensParams) error {
	_, err := q.db.ExecContext(ctx, updateTokens, arg.AccessToken, arg.RefreshToken, arg.ExpiresAt)
	return err
}
